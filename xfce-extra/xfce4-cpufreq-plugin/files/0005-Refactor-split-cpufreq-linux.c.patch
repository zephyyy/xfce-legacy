From b73cc96ddcc54bafe17c83e24d51129d5223cdf3 Mon Sep 17 00:00:00 2001
From: Andre Miranda <andreldm@xfce.org>
Date: Wed, 19 Sep 2018 19:40:44 -0300
Subject: [PATCH 5/6] Refactor: split cpufreq-linux.c

---
 panel-plugin/Makefile.am                  |   8 +-
 panel-plugin/xfce4-cpufreq-linux-procfs.c | 188 +++++++++
 panel-plugin/xfce4-cpufreq-linux-procfs.h |  33 ++
 panel-plugin/xfce4-cpufreq-linux-pstate.c |  92 +++++
 panel-plugin/xfce4-cpufreq-linux-pstate.h |  31 ++
 panel-plugin/xfce4-cpufreq-linux-sysfs.c  | 242 ++++++++++++
 panel-plugin/xfce4-cpufreq-linux-sysfs.h  |  35 ++
 panel-plugin/xfce4-cpufreq-linux.c        | 461 ++--------------------
 panel-plugin/xfce4-cpufreq-linux.h        |   3 -
 po/POTFILES.in                            |   3 +
 10 files changed, 666 insertions(+), 430 deletions(-)
 create mode 100644 panel-plugin/xfce4-cpufreq-linux-procfs.c
 create mode 100644 panel-plugin/xfce4-cpufreq-linux-procfs.h
 create mode 100644 panel-plugin/xfce4-cpufreq-linux-pstate.c
 create mode 100644 panel-plugin/xfce4-cpufreq-linux-pstate.h
 create mode 100644 panel-plugin/xfce4-cpufreq-linux-sysfs.c
 create mode 100644 panel-plugin/xfce4-cpufreq-linux-sysfs.h

diff --git a/panel-plugin/Makefile.am b/panel-plugin/Makefile.am
index c753d15..3c0ee2a 100644
--- a/panel-plugin/Makefile.am
+++ b/panel-plugin/Makefile.am
@@ -19,6 +19,12 @@ libcpufreq_la_LIBADD =						\
 libcpufreq_la_SOURCES =						\
 	xfce4-cpufreq-plugin.h					\
 	xfce4-cpufreq-plugin.c					\
+	xfce4-cpufreq-linux-procfs.h			\
+	xfce4-cpufreq-linux-procfs.c			\
+	xfce4-cpufreq-linux-pstate.h			\
+	xfce4-cpufreq-linux-pstate.c			\
+	xfce4-cpufreq-linux-sysfs.h				\
+	xfce4-cpufreq-linux-sysfs.c				\
 	xfce4-cpufreq-linux.h					\
 	xfce4-cpufreq-linux.c					\
 	xfce4-cpufreq-configure.h				\
@@ -43,5 +49,5 @@ desktop_DATA = $(desktop_in_files:.desktop.in=.desktop)
 EXTRA_DIST = 								\
 	$(desktop_in_files)
 
-DISTCLEANFILES =								\
+DISTCLEANFILES =							\
 	$(desktop_DATA)
diff --git a/panel-plugin/xfce4-cpufreq-linux-procfs.c b/panel-plugin/xfce4-cpufreq-linux-procfs.c
new file mode 100644
index 0000000..89e90db
--- /dev/null
+++ b/panel-plugin/xfce4-cpufreq-linux-procfs.c
@@ -0,0 +1,188 @@
+/*  xfce4-cpu-freq-plugin - panel plugin for cpu informations
+ *
+ *  Copyright (c) 2018 Andre Miranda <andreldm@xfce.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "xfce4-cpufreq-plugin.h"
+#include "xfce4-cpufreq-linux-procfs.h"
+
+#ifndef _
+# include <libintl.h>
+# define _(String) gettext (String)
+#endif
+
+#define PROCFS_BASE "/proc/cpufreq"
+
+
+
+gboolean
+cpufreq_procfs_is_available ()
+{
+  return g_file_test (PROCFS_BASE, G_FILE_TEST_EXISTS);
+}
+
+
+
+gboolean
+cpufreq_procfs_read_cpuinfo ()
+{
+  CpuInfo *cpu;
+  FILE *file;
+  gchar *freq, *filePath, *fileContent;
+  gint i = 0;
+  gboolean add_cpu;
+
+  filePath = g_strdup ("/proc/cpuinfo");
+  if (!g_file_test (filePath, G_FILE_TEST_EXISTS))
+  {
+    g_free (filePath);
+    return FALSE;
+  }
+
+  file = fopen (filePath, "r");
+
+  if (file)
+  {
+    fileContent = g_new (gchar,255);
+    while (fgets (fileContent, 255, file) != NULL)
+    {
+      if (g_ascii_strncasecmp (fileContent, "cpu MHz", 7) == 0)
+      {
+        cpu = NULL;
+        add_cpu = FALSE;
+
+        if (cpuFreq->cpus && cpuFreq->cpus->len > i)
+          cpu = g_ptr_array_index (cpuFreq->cpus, i);
+
+        if (cpu == NULL)
+        {
+          cpu = g_new0 (CpuInfo, 1);
+          cpu->max_freq = 0;
+          cpu->min_freq = 0;
+          cpu->cur_governor = NULL;
+          cpu->available_freqs = NULL;
+          cpu->available_governors = NULL;
+          add_cpu = TRUE;
+        }
+
+        freq = g_strrstr (fileContent, ":");
+
+        if (freq == NULL)
+        {
+          if (add_cpu)
+            cpuinfo_free (cpu);
+          break;
+        }
+
+        sscanf (++freq, "%d.", &cpu->cur_freq);
+        cpu->cur_freq *= 1000;
+
+        if (add_cpu && cpu != NULL)
+          g_ptr_array_add (cpuFreq->cpus, cpu);
+
+        ++i;
+      }
+    }
+
+    fclose (file);
+    g_free (fileContent);
+  }
+
+  g_free (filePath);
+
+  return TRUE;
+}
+
+
+
+gboolean
+cpufreq_procfs_read ()
+{
+  CpuInfo *cpu;
+  FILE *file;
+  gint i;
+  gchar *filePath, *fileContent;
+
+  filePath = g_strdup (PROCFS_BASE);
+  if (!g_file_test (filePath, G_FILE_TEST_EXISTS))
+  {
+    g_free (filePath);
+    return FALSE;
+  }
+
+  file = fopen (filePath, "r");
+
+  if (file)
+  {
+    fileContent = g_new (gchar, 255);
+    while (fgets (fileContent, 255, file) != NULL)
+    {
+      if (g_ascii_strncasecmp (fileContent, "CPU", 3) == 0)
+      {
+        cpu = g_new0 (CpuInfo, 1);
+        cpu->max_freq = 0;
+        cpu->min_freq = 0;
+        cpu->cur_governor = g_new (gchar, 20);
+        cpu->available_freqs = NULL;
+        cpu->available_governors = NULL;
+
+        sscanf (fileContent,
+                "CPU %*d %d kHz (%*d %%) - %d kHz (%*d %%) - %20s",
+                &cpu->min_freq,
+                &cpu->max_freq,
+                cpu->cur_governor);
+        cpu->min_freq *= 1000;
+        cpu->max_freq *= 1000;
+
+        g_ptr_array_add (cpuFreq->cpus, cpu);
+      }
+    }
+
+    fclose (file);
+    g_free (fileContent);
+  }
+
+  g_free (filePath);
+
+  for (i = 0; i < cpuFreq->cpus->len; i++)
+  {
+    cpu = g_ptr_array_index (cpuFreq->cpus, i);
+    filePath = g_strdup_printf ("/proc/sys/cpu/%d/speed", i);
+
+    if (!g_file_test (filePath, G_FILE_TEST_EXISTS))
+    {
+      g_free (filePath);
+      return FALSE;
+    }
+
+    file = fopen (filePath, "r");
+
+    if (file)
+    {
+      fscanf (file, "%d", &cpu->cur_freq);
+      fclose (file);
+    }
+
+    g_free (filePath);
+  }
+
+  return TRUE;
+}
diff --git a/panel-plugin/xfce4-cpufreq-linux-procfs.h b/panel-plugin/xfce4-cpufreq-linux-procfs.h
new file mode 100644
index 0000000..8f19372
--- /dev/null
+++ b/panel-plugin/xfce4-cpufreq-linux-procfs.h
@@ -0,0 +1,33 @@
+/*  xfce4-cpu-freq-plugin - panel plugin for cpu informations
+ *
+ *  Copyright (c) 2018 Andre Miranda <andreldm@xfce.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef XFCE4_CPUFREQ_LINUX_PROCFS_H
+#define XFCE4_CPUFREQ_LINUX_PROCFS_H
+
+G_BEGIN_DECLS
+
+gboolean cpufreq_procfs_is_available (void);
+
+gboolean cpufreq_procfs_read (void);
+
+gboolean cpufreq_procfs_read_cpuinfo (void);
+
+G_END_DECLS
+
+#endif /* XFCE4_CPUFREQ_LINUX_PROCFS_H */
diff --git a/panel-plugin/xfce4-cpufreq-linux-pstate.c b/panel-plugin/xfce4-cpufreq-linux-pstate.c
new file mode 100644
index 0000000..7b5f685
--- /dev/null
+++ b/panel-plugin/xfce4-cpufreq-linux-pstate.c
@@ -0,0 +1,92 @@
+/*  xfce4-cpu-freq-plugin - panel plugin for cpu informations
+ *
+ *  Copyright (c) 2018 Andre Miranda <andreldm@xfce.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "xfce4-cpufreq-plugin.h"
+#include "xfce4-cpufreq-linux-pstate.h"
+#include "xfce4-cpufreq-linux-sysfs.h"
+
+#ifndef _
+# include <libintl.h>
+# define _(String) gettext (String)
+#endif
+
+#define PSTATE_BASE "/sys/devices/system/cpu/intel_pstate"
+
+static gboolean read_params ();
+
+gboolean
+cpufreq_pstate_is_available ()
+{
+  return g_file_test (PSTATE_BASE, G_FILE_TEST_EXISTS);
+}
+
+
+
+gboolean
+cpufreq_pstate_read (void)
+{
+  CpuInfo *cpu;
+  gint i;
+
+  /* gather intel pstate parameters */
+  if (!read_params ())
+    return FALSE;
+
+  /* now read the number of cpus and the remaining cpufreq info
+     for each of them from sysfs */
+  if (!cpufreq_sysfs_read ())
+    return FALSE;
+
+  return TRUE;
+}
+
+
+
+static gboolean
+read_params ()
+{
+  gchar *file, *contents;
+  IntelPState *ips;
+
+  ips = g_slice_new0(IntelPState);
+
+  if (!g_file_test (PSTATE_BASE, G_FILE_TEST_EXISTS))
+    return FALSE;
+
+  file = g_strdup (PSTATE_BASE "/min_perf_pct");
+  cpufreq_sysfs_read_int (file, contents, &ips->min_perf_pct);
+  g_free (file);
+
+  file = g_strdup (PSTATE_BASE "/max_perf_pct");
+  cpufreq_sysfs_read_int (file, contents, &ips->max_perf_pct);
+  g_free (file);
+
+  file = g_strdup (PSTATE_BASE "/no_turbo");
+  cpufreq_sysfs_read_int (file, contents, &ips->no_turbo);
+  g_free (file);
+
+  g_slice_free (IntelPState, cpuFreq->intel_pstate);
+  cpuFreq->intel_pstate = ips;
+
+  return TRUE;
+}
diff --git a/panel-plugin/xfce4-cpufreq-linux-pstate.h b/panel-plugin/xfce4-cpufreq-linux-pstate.h
new file mode 100644
index 0000000..71b0473
--- /dev/null
+++ b/panel-plugin/xfce4-cpufreq-linux-pstate.h
@@ -0,0 +1,31 @@
+/*  xfce4-cpu-freq-plugin - panel plugin for cpu informations
+ *
+ *  Copyright (c) 2018 Andre Miranda <andreldm@xfce.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef XFCE4_CPUFREQ_LINUX_PSTATE_H
+#define XFCE4_CPUFREQ_LINUX_PSTATE_H
+
+G_BEGIN_DECLS
+
+gboolean cpufreq_pstate_is_available (void);
+
+gboolean cpufreq_pstate_read (void);
+
+G_END_DECLS
+
+#endif /* XFCE4_CPUFREQ_LINUX_PSTATE_H */
diff --git a/panel-plugin/xfce4-cpufreq-linux-sysfs.c b/panel-plugin/xfce4-cpufreq-linux-sysfs.c
new file mode 100644
index 0000000..92b89ac
--- /dev/null
+++ b/panel-plugin/xfce4-cpufreq-linux-sysfs.c
@@ -0,0 +1,242 @@
+/*  xfce4-cpu-freq-plugin - panel plugin for cpu informations
+ *
+ *  Copyright (c) 2018 Andre Miranda <andreldm@xfce.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "xfce4-cpufreq-plugin.h"
+#include "xfce4-cpufreq-linux-sysfs.h"
+
+#ifndef _
+# include <libintl.h>
+# define _(String) gettext (String)
+#endif
+
+#define SYSFS_BASE  "/sys/devices/system/cpu"
+
+static void cpufreq_sysfs_read_int_list (gchar *file, gchar *contents, GList **list);
+
+static void cpufreq_sysfs_read_string (gchar *file, gchar *contents, gchar **string);
+
+static void cpufreq_sysfs_read_string_list (gchar *file, gchar *contents, GList **list);
+
+static void parse_sysfs_init (gint cpu_number, CpuInfo *cpu);
+
+static inline gchar* read_file_contents (const gchar *file);
+
+static inline gboolean cpufreq_cpu_exists (gint num);
+
+
+
+gboolean
+cpufreq_sysfs_is_available ()
+{
+  return g_file_test (SYSFS_BASE"/cpu0/cpufreq", G_FILE_TEST_EXISTS);
+}
+
+void
+cpufreq_sysfs_read_current (gint cpu_number)
+{
+  CpuInfo *cpu;
+  gchar	*file, *contents;
+
+  cpu = g_ptr_array_index (cpuFreq->cpus, cpu_number);
+
+  /* read current cpu freq */
+  file = g_strdup_printf (SYSFS_BASE"/cpu%i/cpufreq/scaling_cur_freq", cpu_number);
+  cpufreq_sysfs_read_int (file, contents, &cpu->cur_freq);
+  g_free (file);
+
+  /* read current cpu governor */
+  file = g_strdup_printf (SYSFS_BASE"/cpu%i/cpufreq/scaling_governor", cpu_number);
+  cpufreq_sysfs_read_string (file, contents, &cpu->cur_governor);
+  g_free (file);
+}
+
+
+
+gboolean
+cpufreq_sysfs_read (void)
+{
+  gint count = 0, i = 0;
+  gchar *file;
+
+  while (cpufreq_cpu_exists (count))
+    count++;
+
+  if (count == 0)
+    return FALSE;
+
+  while (i < count)
+    parse_sysfs_init (i++, NULL);
+
+  return TRUE;
+}
+
+
+
+void
+cpufreq_sysfs_read_int (gchar *file, gchar *contents, gint *intval)
+{
+  if (contents = read_file_contents (file)) {
+    (*intval) = atoi (contents);
+    g_free (contents);
+  }
+}
+
+
+
+static void
+cpufreq_sysfs_read_int_list (gchar *file, gchar *contents, GList **list)
+{
+  if (contents = read_file_contents (file)) {
+    gchar **tokens = NULL;
+    gint i = 0;
+    tokens = g_strsplit (contents, " ", 0);
+    g_free (contents);
+    g_list_free (*list);
+    while (tokens[i] != NULL) {
+      gint value = atoi (tokens[i]);
+      *list = g_list_append (*list, GINT_TO_POINTER (value));
+      i++;
+    }
+    g_strfreev (tokens);
+  }
+}
+
+
+static void
+cpufreq_sysfs_read_string (gchar *file,gchar *contents, gchar **string)
+{
+  if (contents = read_file_contents (file)) {
+    g_free (*string);
+    *string = contents;
+  }
+}
+
+
+
+static void
+cpufreq_sysfs_read_string_list (gchar *file, gchar *contents, GList **list)
+{
+  if (contents = read_file_contents (file)) {
+    gchar **tokens = NULL;
+    gint i = 0;
+    tokens = g_strsplit (contents, " ", 0);
+    g_free (contents);
+    g_list_free_full (*list, g_free);
+    while (tokens[i] != NULL) {
+      *list = g_list_append (*list, strdup (tokens[i]));
+      i++;
+    }
+    g_strfreev (tokens);
+  }
+}
+
+
+
+static void
+parse_sysfs_init (gint cpu_number, CpuInfo *cpu)
+{
+  gchar *file, *contents;
+  gboolean add_cpu = FALSE;
+
+  if (cpu == NULL) {
+    cpu = g_new0 (CpuInfo, 1);
+    add_cpu = TRUE;
+  }
+
+  /* read available cpu freqs */
+  if (cpuFreq->intel_pstate == NULL) {
+    file = g_strdup_printf (SYSFS_BASE"/cpu%i/cpufreq/scaling_available_frequencies", cpu_number);
+    cpufreq_sysfs_read_int_list (file, contents, &cpu->available_freqs);
+    g_free (file);
+  }
+
+  /* read available cpu governors */
+  file = g_strdup_printf (SYSFS_BASE"/cpu%i/cpufreq/scaling_available_governors", cpu_number);
+  cpufreq_sysfs_read_string_list (file, contents, &cpu->available_governors);
+  g_free (file);
+
+  /* read cpu driver */
+  file = g_strdup_printf (SYSFS_BASE"/cpu%i/cpufreq/scaling_driver", cpu_number);
+  cpufreq_sysfs_read_string (file, contents, &cpu->scaling_driver);
+  g_free (file);
+
+  /* read current cpu freq */
+  file = g_strdup_printf (SYSFS_BASE"/cpu%i/cpufreq/scaling_cur_freq", cpu_number);
+  cpufreq_sysfs_read_int (file, contents, &cpu->cur_freq);
+  g_free (file);
+
+  /* read current cpu governor */
+  file = g_strdup_printf (SYSFS_BASE"/cpu%i/cpufreq/scaling_governor", cpu_number);
+  cpufreq_sysfs_read_string (file, contents, &cpu->cur_governor);
+  g_free (file);
+
+  /* read max cpu freq */
+  file = g_strdup_printf (SYSFS_BASE"/cpu%i/cpufreq/scaling_max_freq", cpu_number);
+  cpufreq_sysfs_read_int (file, contents, &cpu->max_freq);
+  g_free (file);
+
+  /* read min cpu freq */
+  file = g_strdup_printf (SYSFS_BASE"/cpu%i/cpufreq/scaling_min_freq", cpu_number);
+  cpufreq_sysfs_read_int (file, contents, &cpu->min_freq);
+  g_free (file);
+
+  if (add_cpu)
+    g_ptr_array_add (cpuFreq->cpus, cpu);
+}
+
+
+
+static inline gchar*
+read_file_contents (const gchar *file)
+{
+  GError *error = NULL;
+  gchar *contents = NULL;
+
+  if (!g_file_test (file, G_FILE_TEST_EXISTS))
+    return NULL;
+
+  if (g_file_get_contents (file, &contents, NULL, &error)) {
+    g_strstrip (contents);
+    return contents;
+  }
+
+  g_debug ("Error reading %s: %s\n", file, error->message);
+  g_error_free (error);
+  return NULL;
+}
+
+
+
+static inline gboolean
+cpufreq_cpu_exists (gint num)
+{
+  gchar *file;
+  gboolean ret;
+
+  file = g_strdup_printf ("%s/cpu%d", SYSFS_BASE, num);
+  ret = g_file_test (file, G_FILE_TEST_EXISTS);
+
+  g_free (file);
+
+  return ret;
+}
diff --git a/panel-plugin/xfce4-cpufreq-linux-sysfs.h b/panel-plugin/xfce4-cpufreq-linux-sysfs.h
new file mode 100644
index 0000000..068c0d0
--- /dev/null
+++ b/panel-plugin/xfce4-cpufreq-linux-sysfs.h
@@ -0,0 +1,35 @@
+/*  xfce4-cpu-freq-plugin - panel plugin for cpu informations
+ *
+ *  Copyright (c) 2018 Andre Miranda <andreldm@xfce.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef XFCE4_CPUFREQ_LINUX_SYSFS_H
+#define XFCE4_CPUFREQ_LINUX_SYSFS_H
+
+G_BEGIN_DECLS
+
+gboolean cpufreq_sysfs_is_available (void);
+
+gboolean cpufreq_sysfs_read (void);
+
+void cpufreq_sysfs_read_current (gint cpu_number);
+
+void cpufreq_sysfs_read_int (gchar *file, gchar *contents, gint *intval);
+
+G_END_DECLS
+
+#endif /* XFCE4_CPUFREQ_LINUX_SYSFS_H */
diff --git a/panel-plugin/xfce4-cpufreq-linux.c b/panel-plugin/xfce4-cpufreq-linux.c
index 31b9210..a50d27f 100644
--- a/panel-plugin/xfce4-cpufreq-linux.c
+++ b/panel-plugin/xfce4-cpufreq-linux.c
@@ -25,11 +25,15 @@
 
 #include <stdlib.h>
 #include <dirent.h>
-#include "xfce4-cpufreq-plugin.h"
-#include "xfce4-cpufreq-linux.h"
 
 #include <libxfce4ui/libxfce4ui.h>
 
+#include "xfce4-cpufreq-plugin.h"
+#include "xfce4-cpufreq-linux.h"
+#include "xfce4-cpufreq-linux-procfs.h"
+#include "xfce4-cpufreq-linux-pstate.h"
+#include "xfce4-cpufreq-linux-sysfs.h"
+
 #ifndef _
 # include <libintl.h>
 # define _(String) gettext (String)
@@ -37,415 +41,60 @@
 
 
 
-#define SYSFS_READ_STRING(file, contents, string)   \
-  if (contents = read_sysfs_file_contents (file)) { \
-    g_free (string);                                \
-    string = contents;                              \
-  }
-
-
-
-#define SYSFS_READ_STRING_LIST(file, contents, list)    \
-  if (contents = read_sysfs_file_contents (file)) {     \
-    gchar **tokens = NULL;                              \
-    gint i = 0;                                         \
-    tokens = g_strsplit (contents, " ", 0);             \
-    g_free (contents);                                  \
-    g_list_free_full (list, g_free);                    \
-    while (tokens[i] != NULL) {                         \
-      list = g_list_append (list, strdup (tokens[i]));  \
-      i++;                                              \
-    }                                                   \
-    g_strfreev (tokens);                                \
-  }
-
-
-
-#define SYSFS_READ_INT(file, contents, intval)      \
-  if (contents = read_sysfs_file_contents (file)) { \
-    intval = atoi (contents);                       \
-    g_free (contents);                              \
-  }
-
-
-
-#define SYSFS_READ_INT_LIST(file, contents, list)           \
-  if (contents = read_sysfs_file_contents (file)) {         \
-    gchar **tokens = NULL;                                  \
-    gint i = 0;                                             \
-    tokens = g_strsplit (contents, " ", 0);                 \
-    g_free (contents);                                      \
-    g_list_free (list);                                     \
-    while (tokens[i] != NULL) {                             \
-      gint value = atoi (tokens[i]);                        \
-      list = g_list_append (list, GINT_TO_POINTER (value)); \
-      i++;                                                  \
-    }                                                       \
-    g_strfreev (tokens);                                    \
-  }
-
-
-
-static inline gchar *
-read_sysfs_file_contents (const gchar *file)
-{
-  GError *error = NULL;
-  gchar *contents = NULL;
-
-  if (!g_file_test (file, G_FILE_TEST_EXISTS))
-    return NULL;
-
-  if (g_file_get_contents (file, &contents, NULL, &error)) {
-    g_strstrip (contents);
-    return contents;
-  }
-
-  g_debug ("Error reading %s: %s\n", file, error->message);
-  g_error_free (error);
-  return NULL;
-}
-
-
-
-static void
-cpufreq_cpu_parse_sysfs_init (gint cpu_number, CpuInfo *cpu)
-{
-  gchar *file, *contents;
-  gboolean add_cpu = FALSE;
-
-  if (cpu == NULL) {
-    cpu = g_new0 (CpuInfo, 1);
-    add_cpu = TRUE;
-  }
-
-  /* read available cpu freqs */
-  if (cpuFreq->intel_pstate == NULL) {
-    file = g_strdup_printf ("/sys/devices/system/cpu/cpu%i/"
-                            "cpufreq/scaling_available_frequencies",
-                            cpu_number);
-    SYSFS_READ_INT_LIST (file, contents, cpu->available_freqs);
-    g_free (file);
-  }
-
-  /* read available cpu governors */
-  file = g_strdup_printf ("/sys/devices/system/cpu/cpu%i/"
-                          "cpufreq/scaling_available_governors",
-                          cpu_number);
-  SYSFS_READ_STRING_LIST (file, contents, cpu->available_governors);
-  g_free (file);
-
-  /* read cpu driver */
-  file = g_strdup_printf ("/sys/devices/system/cpu/cpu%i/"
-                          "cpufreq/scaling_driver",
-                          cpu_number);
-  SYSFS_READ_STRING (file, contents, cpu->scaling_driver);
-  g_free (file);
-
-  /* read current cpu freq */
-  file = g_strdup_printf ("/sys/devices/system/cpu/cpu%i/"
-                          "cpufreq/scaling_cur_freq",
-                          cpu_number);
-  SYSFS_READ_INT (file, contents, cpu->cur_freq);
-  g_free (file);
-
-  /* read current cpu governor */
-  file = g_strdup_printf ("/sys/devices/system/cpu/cpu%i/"
-                          "cpufreq/scaling_governor",
-                          cpu_number);
-  SYSFS_READ_STRING (file, contents, cpu->cur_governor);
-  g_free (file);
-
-  /* read max cpu freq */
-  file = g_strdup_printf ("/sys/devices/system/cpu/cpu%i/"
-                          "cpufreq/scaling_max_freq",
-                          cpu_number);
-  SYSFS_READ_INT (file, contents, cpu->max_freq);
-  g_free (file);
-
-  /* read min cpu freq */
-  file = g_strdup_printf ("/sys/devices/system/cpu/cpu%i/"
-                          "cpufreq/scaling_min_freq",
-                          cpu_number);
-  SYSFS_READ_INT (file, contents, cpu->min_freq);
-  g_free (file);
-
-  if (add_cpu)
-    g_ptr_array_add (cpuFreq->cpus, cpu);
-}
-
-
-
-static void
-cpufreq_cpu_read_sysfs_current (gint cpu_number)
-{
-  CpuInfo *cpu;
-  gchar	*file, *contents;
-
-  cpu = g_ptr_array_index (cpuFreq->cpus, cpu_number);
-
-  /* read current cpu freq */
-  file = g_strdup_printf ("/sys/devices/system/cpu/cpu%i/"
-                          "cpufreq/scaling_cur_freq",
-                          cpu_number);
-  SYSFS_READ_INT (file, contents, cpu->cur_freq);
-  g_free (file);
-
-  /* read current cpu governor */
-  file = g_strdup_printf ("/sys/devices/system/cpu/cpu%i/"
-                          "cpufreq/scaling_governor",
-                          cpu_number);
-  SYSFS_READ_STRING (file, contents, cpu->cur_governor);
-  g_free (file);
-}
-
-
-
-static gboolean
-cpufreq_cpu_read_procfs_cpuinfo ()
-{
-  CpuInfo *cpu;
-  FILE *file;
-  gchar *freq, *filePath, *fileContent;
-  gint i = 0;
-  gboolean add_cpu;
-
-  filePath = g_strdup ("/proc/cpuinfo");
-  if (!g_file_test (filePath, G_FILE_TEST_EXISTS))
-  {
-    g_free (filePath);
-    return FALSE;
-  }
-
-  file = fopen (filePath, "r");
-
-  if (file)
-  {
-    fileContent = g_new (gchar,255);
-    while (fgets (fileContent, 255, file) != NULL)
-    {
-      if (g_ascii_strncasecmp (fileContent, "cpu MHz", 7) == 0)
-      {
-        cpu = NULL;
-        add_cpu = FALSE;
-
-        if (cpuFreq->cpus && cpuFreq->cpus->len > i)
-          cpu = g_ptr_array_index (cpuFreq->cpus, i);
-
-        if (cpu == NULL)
-        {
-          cpu = g_new0 (CpuInfo, 1);
-          cpu->max_freq = 0;
-          cpu->min_freq = 0;
-          cpu->cur_governor = NULL;
-          cpu->available_freqs = NULL;
-          cpu->available_governors = NULL;
-          add_cpu = TRUE;
-        }
-
-        freq = g_strrstr (fileContent, ":");
-
-        if (freq == NULL)
-        {
-          if (add_cpu)
-            cpuinfo_free (cpu);
-          break;
-        }
-
-        sscanf (++freq, "%d.", &cpu->cur_freq);
-        cpu->cur_freq *= 1000;
-
-        if (add_cpu && cpu != NULL)
-          g_ptr_array_add (cpuFreq->cpus, cpu);
-
-        ++i;
-      }
-    }
-
-    fclose (file);
-    g_free (fileContent);
-  }
-
-  g_free (filePath);
-
-  return TRUE;
-}
-
-
-
-static gboolean
-cpufreq_cpu_read_procfs ()
+gboolean
+cpufreq_linux_init (void)
 {
-  CpuInfo *cpu;
-  FILE *file;
-  gint i;
-  gchar *filePath, *fileContent;
-
-  filePath = g_strdup ("/proc/cpufreq");
-  if (!g_file_test (filePath, G_FILE_TEST_EXISTS))
-  {
-    g_free (filePath);
+  if (cpuFreq->cpus == NULL)
     return FALSE;
-  }
 
-  file = fopen (filePath, "r");
+  if (cpufreq_sysfs_is_available ())
+    return cpufreq_sysfs_read ();
 
-  if (file)
+  if (cpufreq_pstate_is_available ())
   {
-    fileContent = g_new (gchar, 255);
-    while (fgets (fileContent, 255, file) != NULL)
-    {
-      if (g_ascii_strncasecmp (fileContent, "CPU", 3) == 0)
-      {
-        cpu = g_new0 (CpuInfo, 1);
-        cpu->max_freq = 0;
-        cpu->min_freq = 0;
-        cpu->cur_governor = g_new (gchar, 20);
-        cpu->available_freqs = NULL;
-        cpu->available_governors = NULL;
-
-        sscanf (fileContent,
-                "CPU %*d %d kHz (%*d %%) - %d kHz (%*d %%) - %20s",
-                &cpu->min_freq,
-                &cpu->max_freq,
-                cpu->cur_governor);
-        cpu->min_freq *= 1000;
-        cpu->max_freq *= 1000;
+    gboolean ret = cpufreq_pstate_read ();
 
-        g_ptr_array_add (cpuFreq->cpus, cpu);
-      }
+    /* Tools like i7z show the current real frequency using the
+       current maximum performance. Assuming this is the proper
+       way to do it, let's choose the maximum per default. Most
+       CPUs nowadays have more than one core anyway, so there will
+       not be much use in showing a single core's performance
+       value. Besides, it's not very likely the user wants to
+       follow values for 4 or 8 cores per second. */
+    if (ret && cpuFreq->options->show_warning) {
+      cpuFreq->options->show_cpu = CPU_MAX;
+      cpuFreq->options->show_warning = FALSE;
     }
 
-    fclose (file);
-    g_free (fileContent);
+    return ret;
   }
 
-  g_free (filePath);
+  if (cpufreq_procfs_is_available ())
+    return cpufreq_procfs_read ();
 
-  for (i = 0; i < cpuFreq->cpus->len; i++)
+  if (cpuFreq->options->show_warning)
   {
-    cpu = g_ptr_array_index (cpuFreq->cpus, i);
-    filePath = g_strdup_printf ("/proc/sys/cpu/%d/speed", i);
-
-    if (!g_file_test (filePath, G_FILE_TEST_EXISTS))
-    {
-      g_free (filePath);
-      return FALSE;
-    }
-
-    file = fopen (filePath, "r");
-
-    if (file)
-    {
-      fscanf (file, "%d", &cpu->cur_freq);
-      fclose (file);
-    }
-
-    g_free (filePath);
+    xfce_dialog_show_warning (NULL, NULL,
+      _("Your system does not support cpufreq.\nThe applet only shows the current cpu frequency"));
+    cpuFreq->options->show_warning = FALSE;
   }
 
-  return TRUE;
-}
-
-
-
-static inline gboolean
-cpufreq_cpu_exists (gint num)
-{
-  gchar *file;
-  gboolean ret;
-  const gchar *base = "/sys/devices/system/cpu";
-
-  file = g_strdup_printf ("%s/cpu%d", base, num);
-  ret = g_file_test (file, G_FILE_TEST_EXISTS);
-
-  g_free (file);
-
-  return ret;
-}
-
-
-
-static gboolean
-cpufreq_cpu_read_sysfs (void)
-{
-  gint count = 0, i = 0;
-  gchar *file;
-
-  while (cpufreq_cpu_exists (count))
-    count++;
-
-  if (count == 0)
-    return FALSE;
-
-  while (i < count)
-    cpufreq_cpu_parse_sysfs_init (i++, NULL);
-
-  return TRUE;
+  return cpufreq_procfs_read_cpuinfo ();
 }
 
 
 
-gboolean
-cpufreq_intel_pstate_params (void)
-{
-  gchar *file, *contents;
-  IntelPState *ips;
-
-  ips = g_slice_new0(IntelPState);
-
-  if (!g_file_test ("/sys/devices/system/cpu/intel_pstate", G_FILE_TEST_EXISTS))
-    return FALSE;
-
-  file = g_strdup ("/sys/devices/system/cpu/intel_pstate/min_perf_pct");
-  SYSFS_READ_INT (file, contents, ips->min_perf_pct);
-  g_free (file);
-
-  file = g_strdup ("/sys/devices/system/cpu/intel_pstate/max_perf_pct");
-  SYSFS_READ_INT (file, contents, ips->max_perf_pct);
-  g_free (file);
-
-  file = g_strdup ("/sys/devices/system/cpu/intel_pstate/no_turbo");
-  SYSFS_READ_INT (file, contents, ips->no_turbo);
-  g_free (file);
-
-  g_slice_free (IntelPState, cpuFreq->intel_pstate);
-  cpuFreq->intel_pstate = ips;
-
-  return TRUE;
-}
-
-
-
-static gboolean
-cpufreq_cpu_intel_pstate_read ()
-{
-  CpuInfo *cpu;
-  gint i;
-
-  /* gather intel pstate parameters */
-  if (!cpufreq_intel_pstate_params ())
-    return FALSE;
-
-  /* now read the number of cpus and the remaining cpufreq info
-     for each of them from sysfs */
-  if (!cpufreq_cpu_read_sysfs ())
-    return FALSE;
-
-  return TRUE;
-}
-
 gboolean
 cpufreq_update_cpus (gpointer data)
 {
   gint i;
 
-  if (g_file_test ("/sys/devices/system/cpu/cpu0/cpufreq",
-                         G_FILE_TEST_EXISTS))
+  if (cpufreq_sysfs_is_available ())
   {
     for (i = 0; i < cpuFreq->cpus->len; i++)
-      cpufreq_cpu_read_sysfs_current (i);
+      cpufreq_sysfs_read_current (i);
   }
-  else if (g_file_test ("/proc/cpufreq", G_FILE_TEST_EXISTS))
+  else if (cpufreq_procfs_is_available ())
   {
     /* First we delete the cpus and then read the /proc/cpufreq file again */
     for (i = 0; i < cpuFreq->cpus->len; i++)
@@ -454,7 +103,7 @@ cpufreq_update_cpus (gpointer data)
       g_ptr_array_remove_fast (cpuFreq->cpus, cpu);
       cpuinfo_free (cpu);
     }
-    cpufreq_cpu_read_procfs ();
+    cpufreq_procfs_read ();
   }
   else
   {
@@ -464,43 +113,3 @@ cpufreq_update_cpus (gpointer data)
 
   return cpufreq_update_plugin (FALSE);
 }
-
-gboolean
-cpufreq_linux_init (void)
-{
-  if (cpuFreq->cpus == NULL)
-    return FALSE;
-
-  if (g_file_test ("/sys/devices/system/cpu/cpu0/cpufreq", G_FILE_TEST_EXISTS))
-    return cpufreq_cpu_read_sysfs ();
-
-  if (g_file_test ("/sys/devices/system/cpu/intel_pstate", G_FILE_TEST_EXISTS))
-  {
-    gboolean ret = cpufreq_cpu_intel_pstate_read ();
-
-    /* Tools like i7z show the current real frequency using the
-       current maximum performance. Assuming this is the proper
-       way to do it, let's choose the maximum per default. Most
-       CPUs nowadays have more than one core anyway, so there will
-       not be much use in showing a single core's performance
-       value. Besides, it's not very likely the user wants to
-       follow values for 4 or 8 cores per second. */
-    if (ret && cpuFreq->options->show_warning) {
-      cpuFreq->options->show_cpu = CPU_MAX;
-      cpuFreq->options->show_warning = FALSE;
-    }
-
-    return ret;
-  }
-
-  if (g_file_test ("/proc/cpufreq", G_FILE_TEST_EXISTS))
-    return cpufreq_cpu_read_procfs ();
-
-  if (cpuFreq->options->show_warning)
-  {
-    xfce_dialog_show_warning (NULL, NULL, _("Your system does not support cpufreq.\nThe applet only shows the current cpu frequency"));
-    cpuFreq->options->show_warning = FALSE;
-  }
-
-  return cpufreq_cpu_read_procfs_cpuinfo ();
-}
diff --git a/panel-plugin/xfce4-cpufreq-linux.h b/panel-plugin/xfce4-cpufreq-linux.h
index 3814630..059fd0f 100644
--- a/panel-plugin/xfce4-cpufreq-linux.h
+++ b/panel-plugin/xfce4-cpufreq-linux.h
@@ -26,9 +26,6 @@ G_BEGIN_DECLS
 gboolean
 cpufreq_update_cpus (gpointer data);
 
-gboolean
-cpufreq_intel_pstate_params (void);
-
 gboolean
 cpufreq_linux_init (void);
 
diff --git a/po/POTFILES.in b/po/POTFILES.in
index eb05e65..6ed6561 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -1,4 +1,7 @@
 panel-plugin/xfce4-cpufreq-configure.c
+panel-plugin/xfce4-cpufreq-linux-procfs.c
+panel-plugin/xfce4-cpufreq-linux-pstate.c
+panel-plugin/xfce4-cpufreq-linux-sysfs.c
 panel-plugin/xfce4-cpufreq-linux.c
 panel-plugin/xfce4-cpufreq-overview.c
 panel-plugin/xfce4-cpufreq-plugin.c
-- 
2.45.2

